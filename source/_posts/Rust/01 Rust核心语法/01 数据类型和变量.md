---
title: "01 数据类型和变量"
date: 1766125929
updated: 1766125929
tags: []
categories:
  - "Rust"
---

## 如何速通各种语言

![如何速通](image/2025-08-21T02:34:52.388Z.png)

一个语言应该包括以下几个部分

* 核心语法：数据类型和变量、控制流程、数据结构、函数、面向对象、其他
* 内置工具库：数学、日期、字符串、系统、序列化等
* 内置高阶库：文件IO、网络编程、并发编程
* 生态库：Web框架、客户端、分布式
* 编译原理：虚拟机

## 安装

1. 安装rustup，用来管理rust版本的工具。
```sh
$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
```
2. 安装更新rust
```
rustup update
```
3. 查看安装的版本
```
rustc --version
```

## 优势分析

1. 所有权\move语法\借用引用
2. 表达式与语句概念


## 变量

### 变量和常量
1. 默认情况下是不可变的。这也是rust的设计哲学之一：通过默认的方式避免掉了很多种可能会出现的错误，非常好的设计思路，将最稳定、最安全的方式作为默认的方式。
2. 可变变量使用mut关键字修饰。
```
let mut x = 5;
x =6;
```
3. 常量使用const关键字修饰。必须在声明的时候初始化，只能是字面常量或者常量表达式，不能是函数调用结果，因为要在编译阶段计算常量的值。常量可以在任意作用域内声明，包括全局作用域，这对于代码中很多部分都需要知道一个值的情况特别有用。
```
const X:i32 = 5;
```
4. 变量遮蔽。可以声明和前面变量具有相同名称的新变量。通过使用相同的变量名并重复使用 let 关键字来遮蔽变量。其实变量遮蔽功能跟变量支持重复赋值功能已经没有什么区别了，但是换了一个概念，就解决了内存管理的问题，太厉害了。
   1. mut和变量遮蔽不同。变量遮蔽可以讲变量声明为不同的类型。而且新的变量有自己的地址。
```
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
}
```


## 数据类型

### 数据类型的规则

Rust 是一种静态类型（statically typed）的语言，每个值都有确切的数据类型（data type），必须在编译期知道所有变量的类型。


标量（scalar）类型表示单个值。Rust 有 4 个基本的标量类型：整型、浮点型、布尔型和字符。

### 整型
整型。每个定义形式要么是有符号类型要么是无符号类型，且带有一个显式的大小。有符号和无符号表示数字能否取负数——也就是说，这个数是否可能是负数（有符号类型），或一直为正而不需要带上符号（无符号类型）。就像在纸上写数字一样：当要强调符号时，数字前面可以带上正号或负号；然而，当很明显确定数字为正数时，就不需要加上正号了。有符号数字以二进制补码（译者补充：“补码”百度百科）形式存储。
```
8 位	i8	u8
16 位	i16	u16
32 位	i32	u32
64 位	i64	u64
128 位	i128	u128
arch	isize	usize
```
Rust 的整型字面量
```
数字字面量	示例
十进制	98_222
十六进制	0xff
八进制	0o77
二进制	0b1111_0000
字节 (仅限于 u8)	b'A'
```
Rust 的所有数字类型都支持基本数学运算：加法、减法、乘法、除法和取模运算。整数除法会向下取整。

### 浮点类型
浮点数（floating-point number）是带有小数点的数字，在 Rust 中浮点类型（简称浮点型）数字也有两种基本类型。Rust 的浮点型是 f32 和 f64，它们的大小分别为 32 位和 64 位。


```
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
```

### 布尔类型
和大多数编程语言一样，Rust 中的布尔类型也有两个可能的值：true 和 false。布尔值的大小为 1 个字节。Rust 中的布尔类型使用 bool 声明。

```rs
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
```

### 复合类型-元祖

复合类型（compound type）可以将多个值组合成一个类型。Rust 有两种基本的复合类型：元组（tuple）和数组（array）。


元组是将多种类型的多个值组合到一个复合类型中的一种基本方式。元组的长度是固定的：声明后，它们就无法增长或缩小。

元组中的每个位置都有一个类型，并且元组中不同值的类型不要求是相同的。
```rs
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```
使用模式匹配来解构（destructure）元组的一个值
```rs
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
```
使用一个句点（.）连上要访问的值的索引来直接访问元组元素。
```rs
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```

### 复合类型-数组

将多个值组合在一起的另一种方式就是使用数组（array）。与元组不同，数组的每个元素必须具有相同的类型。与某些其他语言中的数组不同，Rust 中的数组具有固定长度。
```rs
fn main() {
    // 直接初始化
    let a = [1, 2, 3, 4, 5];
    // 隐含的类型
    let a: [i32; 5] = [1, 2, 3, 4, 5];
    // 重复元素初始化
    let a = [3; 5];

}
```





## 注释

```rust
// Hello, world.

fn main() {
    let lucky_number = 7; // I’m feeling lucky today
}
```



## 语句和表达式

> 这个设计也太舒服了，非常非常符合直觉且非常好用

所有的代码块都支持两种形式，语句或者表达式。语句就是执行一段代码，表达式就是返回一个值，表达式返回值的可以用于给变量赋值形成语句、用于循环的判断条件等。这里重点讲表达式。

1. 最简单的表达式
```rust
5 + 6 //这是一个表达式
a = 5 + 6; //这是一个利用表达式的赋值语句
```
2. 代码块表达式
```rust
{
    let a = 5;
    a
} //这是一个代码块表达式

test = {
    let a = 5;
    a
}; //这是一个表达式赋值语句
```
3. 函数表达式
4. 条件语句表达式
5. 宏表达式
